package mockgen

import (
	"bytes"
	"go/format"
	"io"
	"path"
	"strings"
	"text/template"

	"github.com/Masterminds/sprig/v3"
	"github.com/effective-security/xlog"
	"github.com/pkg/errors"
	"google.golang.org/protobuf/compiler/protogen"
)

var logger = xlog.NewPackageLogger("github.com/effective-security/protoc-gen-go", "go-mock")

// Options are the options to set for rendering the template.
type Options struct {
	// Package provides package name for the Mock
	Package string
	// Prefix specifies prefix to be added to message types:
	// {{.Prefix}}{{.Message.GoName}}
	// If not provided, the the package name of the process file will be used.
	Prefix string
}

// This function is called with a param which contains the entire definition of a method.
func ApplyTemplate(w io.Writer, f *protogen.File, opts Options) error {
	if opts.Prefix == "" {
		opts.Prefix = string(f.GoPackageName) + "."
	}
	if !strings.HasSuffix(opts.Prefix, ".") {
		opts.Prefix = opts.Prefix + "."
	}

	buf := &bytes.Buffer{}
	if err := headerTemplate.Execute(buf, tplHeader{
		File:    f,
		Options: opts,
	}); err != nil {
		return errors.Wrapf(err, "failed to execute template: %s", f.GeneratedFilenamePrefix)
	}

	if err := applyServices(buf, f.Services, opts); err != nil {
		return err
	}

	code, err := format.Source(buf.Bytes())
	if err != nil {
		return errors.Wrapf(err, "failed to format source: %s", f.GeneratedFilenamePrefix)
	}
	_, err = w.Write(code)
	return err

}

func applyServices(w io.Writer, svcs []*protogen.Service, opts Options) error {
	for _, svc := range svcs {
		logger.Infof("Processing %s", svc.GoName)

		structName := "Mock" + svc.GoName + "Server"
		if err := serviceTemplate.Execute(w, tplService{
			Service:    svc,
			Options:    opts,
			StructName: structName,
		}); err != nil {
			return errors.Wrapf(err, "failed to execute template: %s", svc.GoName)
		}

		for _, met := range svc.Methods {
			if err := methodTemplate.Execute(w, tplMethod{
				Method:     met,
				Options:    opts,
				StructName: structName,
			}); err != nil {
				return errors.Wrapf(err, "failed to execute template: %s", met.GoName)
			}
		}
	}

	return nil
}

func tempFuncs() template.FuncMap {
	m := sprig.TxtFuncMap()
	m["type"] = func(f *protogen.Message) string {
		return path.Base(string(f.GoIdent.GoImportPath)) + "." + f.GoIdent.GoName
	}
	return m
}

type tplHeader struct {
	Options

	File *protogen.File
}

type tplService struct {
	Options

	Service    *protogen.Service
	StructName string
}

type tplMethod struct {
	Options

	Method     *protogen.Method
	StructName string
}

var (
	headerTemplate = template.Must(template.New("header").
			Funcs(tempFuncs()).
			Parse(`
// Code generated by protoc-gen-go-mock. DO NOT EDIT.
// source: {{.File.Proto.Name}}

package {{.Package}}

import (
	"context"

	{{.File.GoImportPath}}
	"google.golang.org/protobuf/proto"
)
`))

	serviceTemplate = template.Must(template.New("service").
			Funcs(tempFuncs()).
			Parse(`
// {{.StructName}} for testing
type {{.StructName}} struct {
	{{.Prefix}}{{.Service.GoName}}Server

	Reqs []proto.Message

	// If set, all calls return this error.
	Err error

	// responses to return if err == nil
	Resps []proto.Message
	Index int
}


// SetResponse sets a single response without errors
func (m *{{.StructName}}) SetResponse(r proto.Message) {
	m.Err = nil
	m.Resps = []proto.Message{r}
	m.Index = 0
}

func (m *{{.StructName}}) next() proto.Message {
	c := len(m.Resps)
	idx := m.Index
	m.Index++
	if idx >= c {
		idx = c - 1
	}
	return m.Resps[idx]
}	
`))

	methodTemplate = template.Must(template.New("method").
			Funcs(tempFuncs()).
			Parse(`
{{- .Method.Comments.Leading -}}
func (m *{{.StructName}}) {{.Method.GoName}}(ctx context.Context, req *{{type .Method.Input}}) (*{{type .Method.Output}}, error) {
	if m.Err != nil {
		return nil, m.Err
	}
	return m.next().(*{{type .Method.Output}}), nil
}
`))
)
