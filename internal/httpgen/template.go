package httpgen

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"path"
	"strings"
	"text/template"

	"github.com/Masterminds/sprig/v3"
	"github.com/effective-security/porto/xhttp/httperror"
	"github.com/effective-security/xlog"
	"github.com/pkg/errors"
	"google.golang.org/protobuf/compiler/protogen"
)

var logger = xlog.NewPackageLogger("github.com/effective-security/protoc-gen-go", "go-http")

// simply add ref
var _ = httperror.Error{}

// Options are the options to set for rendering the template.
type Options struct {
	// Package provides package name for the HTTP handler
	Package string
	// PbPackage provides package name for the main protobuf types
	PbPackage string
	// Prefix specifies prefix to be added to message types:
	// {{.Prefix}}{{.Message.GoName}}
	// If not provided, the the package name of the process file will be used.
	Prefix string
}

// This function is called with a param which contains the entire definition of a method.
func ApplyTemplate(w io.Writer, f *protogen.File, opts Options) error {
	if opts.Prefix == "" {
		opts.Prefix = string(f.GoPackageName) + "."
	}
	if !strings.HasSuffix(opts.Prefix, ".") {
		opts.Prefix = opts.Prefix + "."
	}

	buf := &bytes.Buffer{}
	if err := headerTemplate.Execute(buf, tplHeader{
		File:    f,
		Options: opts,
	}); err != nil {
		return errors.Wrapf(err, "failed to execute template: %s", f.GeneratedFilenamePrefix)
	}

	if err := applyServices(buf, f.Services, opts); err != nil {
		return err
	}
	src := buf.Bytes()
	code, err := format.Source(src)
	if err != nil {
		fmt.Printf("failed to format source: %s\n%s\n", f.GeneratedFilenamePrefix, string(src))
		return errors.Wrapf(err, "failed to format source: %s", f.GeneratedFilenamePrefix)
	}
	_, err = w.Write(code)
	return err
}

func applyServices(w io.Writer, svcs []*protogen.Service, opts Options) error {
	for _, svc := range svcs {
		logger.Infof("Processing %s", svc.GoName)

		if err := serviceTemplate.Execute(w, tplService{
			Service:    svc,
			Options:    opts,
			ServerName: svc.GoName + "Server",
		}); err != nil {
			return errors.Wrapf(err, "failed to execute template: %s", svc.GoName)
		}

		for _, met := range svc.Methods {
			if err := methodTemplate.Execute(w, tplMethod{
				Service:   svc,
				Method:    met,
				Options:   opts,
				Namespace: string(svc.Desc.FullName()),
			}); err != nil {
				return errors.Wrapf(err, "failed to execute template: %s", met.GoName)
			}
		}

		if err := footerTemplate.Execute(w, nil); err != nil {
			return errors.Wrapf(err, "failed to execute template: %s", svc.GoName)
		}

	}

	return nil
}

func tempFuncs() template.FuncMap {
	m := sprig.TxtFuncMap()
	m["type"] = func(f *protogen.Message) string {
		return path.Base(string(f.GoIdent.GoImportPath)) + "." + f.GoIdent.GoName
	}
	return m
}

type tplHeader struct {
	Options

	File *protogen.File
}

type tplService struct {
	Options

	Service    *protogen.Service
	ServerName string
}

type tplMethod struct {
	Options

	Service   *protogen.Service
	Method    *protogen.Method
	Namespace string
}

var (
	headerTemplate = template.Must(template.New("header").
			Funcs(tempFuncs()).
			Parse(`
// Code generated by protoc-gen-go-http. DO NOT EDIT.
// source: {{.File.Proto.Name}}

package {{.Package}}

import (
	"context"
	"net/http"

	{{.File.GoImportPath}}
	"google.golang.org/protobuf/proto"
	"github.com/effective-security/porto/restserver"
	"github.com/effective-security/porto/xhttp/correlation"
	"github.com/effective-security/porto/xhttp/httperror"
	"github.com/effective-security/porto/pkg/retriable"
)
`))

	serviceTemplate = template.Must(template.New("service").
			Funcs(tempFuncs()).
			Parse(`
			
// Get{{.Service.GoName}}HTTPHandler handles HTTP requests for {{.Service.GoName}} service
func Get{{.Service.GoName}}HTTPHandler(s {{.PbPackage}}.{{.Service.GoName}}Server, withAccessCheck {{.PbPackage}}.CheckAccessFunc) restserver.Handle {
	return func(w http.ResponseWriter, r *http.Request, p restserver.Params) {
		action := r.URL.Path
		ctx := correlation.WithMetaFromRequest(r)

		var err error
		var res any

		req, _, err := {{.PbPackage}}.UnmarshalRequest(w, r)
		if err != nil {
			// UnmarshalRequest already writes error response
			return
		}

		if withAccessCheck != nil {
			err = withAccessCheck(ctx, req, action)
			if err != nil {
				marshal.WriteJSON(w, r, err)
				return
			}
		}

		switch action {
`))

	methodTemplate = template.Must(template.New("method").
			Funcs(tempFuncs()).
			Parse(`

		case {{.PbPackage}}.{{.Service.GoName}}_{{.Method.GoName}}_FullMethodName:
			res, err = s.{{.Method.GoName}}(ctx, req.(*{{type .Method.Input}}))

`))

	footerTemplate = template.Must(template.New("footer").
			Parse(`
		default:
			err = httperror.Malformed("invalid action: %s", action)
		}
		if err != nil {
			marshal.WriteJSON(w, r, err)
			return
		}

		marshal.WriteJSON(w, r, res)
	}
}
`))
)
