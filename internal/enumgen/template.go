package enumgen

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"path"
	"strings"
	"text/template"

	"github.com/Masterminds/sprig/v3"
	"github.com/effective-security/protoc-gen-go/api"
	"github.com/effective-security/x/enum"
	"github.com/effective-security/xlog"
	"github.com/pkg/errors"
	"google.golang.org/protobuf/compiler/protogen"
)

var logger = xlog.NewPackageLogger("github.com/effective-security/protoc-gen-go", "enumgen")

// simply add ref
type fakeEnum = enum.Enum

// This function is called with a param which contains the entire definition of a method.
func ApplyTemplate(w io.Writer, f *protogen.File) error {
	buf := &bytes.Buffer{}
	if err := headerTemplate.Execute(buf, tplHeader{
		File: f,
	}); err != nil {
		return errors.Wrapf(err, "failed to execute template: %s", f.GeneratedFilenamePrefix)
	}

	err := applyEnums(buf, f.Enums)
	if err != nil {
		return err
	}
	err = applyMessages(buf, f.Messages)
	if err != nil {
		return err
	}

	src := buf.Bytes()
	code, err := format.Source(src)
	if err != nil {
		fmt.Printf("failed to format source: %s\n%s\n", f.GeneratedFilenamePrefix, string(src))
		return errors.Wrapf(err, "failed to format source: %s", f.GeneratedFilenamePrefix)
	}
	_, err = w.Write(code)
	return err
}

func applyEnums(w io.Writer, enums []*protogen.Enum) error {
	for _, en := range enums {
		logger.Infof("Processing %s", en.GoIdent.GoName)
		desc := createEnumDescription(en)
		if err := enumTemplate.Execute(w, tplEnum{
			Enum:        en,
			Description: desc,
		}); err != nil {
			return errors.Wrapf(err, "failed to execute template: %s", en.GoIdent.GoName)
		}
	}

	return nil
}

func applyMessages(w io.Writer, msgs []*protogen.Message) error {
	for _, msg := range msgs {
		if len(msg.Enums) == 0 {
			continue
		}

		for _, en := range msg.Enums {
			logger.Infof("Processing %s_%s", msg.GoIdent.GoName, en.GoIdent.GoName)

			desc := createEnumDescription(en)
			if err := enumTemplate.Execute(w, tplEnum{
				Enum:        en,
				Description: desc,
			}); err != nil {
				return errors.Wrapf(err, "failed to execute template: %s", en.GoIdent.GoName)
			}
		}
	}

	return nil
}

func tempFuncs() template.FuncMap {
	m := sprig.TxtFuncMap()
	m["type"] = func(f *protogen.Message) string {
		return path.Base(string(f.GoIdent.GoImportPath)) + "." + f.GoIdent.GoName
	}
	m["supported"] = func(f *protogen.Enum) string {
		var names []string
		for _, v := range f.Values {
			names = append(names, string(v.Desc.Name()))
		}
		return strings.Join(names, ",")
	}
	m["enum_name"] = func(f *protogen.Enum, name string) string {
		return strings.TrimSuffix(f.GoIdent.GoName, "_Enum") + "_" + name
	}
	m["list"] = func(vals []string) string {
		if len(vals) == 0 {
			return "nil"
		}
		var result []string
		for _, v := range vals {
			result = append(result, fmt.Sprintf("\"%s\"", v))
		}
		return "[]string{" + strings.Join(result, ",") + "}"
	}
	return m
}

type tplHeader struct {
	*protogen.File
}

type tplEnum struct {
	Enum        *protogen.Enum
	Message     *protogen.Message
	Description *api.EnumDescription
}

var (
	headerTemplate = template.Must(template.New("header").
			Funcs(tempFuncs()).
			Parse(`
// Code generated by protoc-gen-go-json. DO NOT EDIT.
// source: {{.Proto.Name}}

package {{.GoPackageName}}

import (
	{{.GoImportPath}}
	"google.golang.org/protobuf/proto"
	"github.com/effective-security/x/enum"
	"github.com/effective-security/protoc-gen-go/api"
)
`))

	enumTemplate = template.Must(template.New("enum").
			Funcs(tempFuncs()).
			Parse(`
//
// {{.Enum.GoIdent.GoName}}
//

const {{.Enum.GoIdent.GoName}}_SupportedNamesHelp = "{{supported .Enum}}"

// ValuesMap returns map of enum values
func (s {{.Enum.GoIdent.GoName}}) ValuesMap() map[string]int32 {
	return {{.Enum.GoIdent.GoName}}_value
}

// NamesMap returns map of enum names	
func (s {{.Enum.GoIdent.GoName}}) NamesMap() map[int32]string {
	return {{.Enum.GoIdent.GoName}}_name
}

// SupportedNames returns string of supported Enum name concatenated by ","	
func (s {{.Enum.GoIdent.GoName}}) SupportedNames() string {
	return enum.SupportedNames[{{.Enum.GoIdent.GoName}}]()
}

// ValueNames returns list of Enum value names
func (s {{.Enum.GoIdent.GoName}}) ValueNames() []string {
	return enum.FlagNames(s)
}

// ValueString returns string of Enum value names concatenated by ","
func (s {{.Enum.GoIdent.GoName}}) ValueString() string {
	return strings.Join(s.ValueNames(), ",")
}

// Flags returns list of Enum values
func (s {{.Enum.GoIdent.GoName}}) Flags() []{{.Enum.GoIdent.GoName}} {
	return enum.Flags(s)
}

// FlagsInt returns list of Enum values as int32
func (s {{.Enum.GoIdent.GoName}}) FlagsInt() []int32 {
	return enum.FlagsInt(s)
}

// UnmarshalYAML unmarshals Enum from YAML
func (s *{{.Enum.GoIdent.GoName}}) UnmarshalYAML(unmarshal func(any) error) error {
	// Try to unmarshal as an integer
	var valInt int32
	if err := unmarshal(&valInt); err == nil {
		*s = {{.Enum.GoIdent.GoName}}(valInt)
		return nil
	}

	// Try to unmarshal as a string
	var valStr string
	if err := unmarshal(&valStr); err == nil {
		*s = enum.Parse[{{.Enum.GoIdent.GoName}}](valStr)
		return nil
	}

	// If both attempts fail, set to default
	*s = 0
	return nil
}

// DisplayNames returns display names of Enum bitflag value
func (s {{.Enum.GoIdent.GoName}}) DisplayNames() []string {
	flags := enum.Flags(s)
	count := len(flags)
	if count == 0 {
		return nil
	}
	if count == 1 {
		return []string{ {{.Enum.GoIdent.GoName}}_DisplayName[flags[0]] }
	}
	var names []string
	for _, flag := range flags {
		names = append(names, {{.Enum.GoIdent.GoName}}_DisplayName[flag])
	}
	return names
}

// DisplayName returns display name of Enum value
func (s {{.Enum.GoIdent.GoName}}) DisplayName() string {
	flags := enum.Flags(s)
	count := len(flags)
	if count == 0 {
		return ""
	}
	if count == 1 {
		return {{.Enum.GoIdent.GoName}}_DisplayName[flags[0]]
	}
	var names []string
	for _, flag := range flags {
		names = append(names, {{.Enum.GoIdent.GoName}}_DisplayName[flag])
	}
	return strings.Join(names, ",")
}

// Meta returns Enum meta information
func (s {{.Enum.GoIdent.GoName}}) Meta() *api.EnumMeta {
	return {{.Enum.GoIdent.GoName}}_Meta[s]
}

// Describe returns Enum meta information for all values
func (s {{.Enum.GoIdent.GoName}}) Describe() map[{{.Enum.GoIdent.GoName}}]*api.EnumMeta {
	return {{.Enum.GoIdent.GoName}}_Meta
}

var {{.Enum.GoIdent.GoName}}_Name = map[{{.Enum.GoIdent.GoName}}]string {
{{- with .Enum }}
{{- range $.Description.Enums }}
	{{enum_name $.Enum .Name}}: "{{.Name}}",
{{- end }}
{{- end }}
}

var {{.Enum.GoIdent.GoName}}_Value = map[string]{{.Enum.GoIdent.GoName}} {
{{- with .Enum }}
{{- range $.Description.Enums }}
	"{{.Name}}":{{enum_name $.Enum .Name}},
{{- end }}
{{- end }}
}

var {{.Enum.GoIdent.GoName}}_DisplayName = map[{{.Enum.GoIdent.GoName}}]string {
{{- with .Enum }}
{{- range $.Description.Enums }}
	{{enum_name $.Enum .Name}}: "{{.Display}}",
{{- end }}
{{- end }}
}

var {{.Enum.GoIdent.GoName}}_Meta = map[{{.Enum.GoIdent.GoName}}]*api.EnumMeta {
	{{- with .Enum }}
	{{- range $.Description.Enums }}
	{{enum_name $.Enum .Name}}: {
		Value:         {{.Value}},
		Name:          "{{.Name}}",
		Display:       "{{.Display}}",
		{{- if .Args }}
		Args:          {{list .Args}},
		{{- end }}
		{{- if .Documentation }}
		Documentation: ` + "`{{.Documentation}}`" + `,
		{{- end }}
	},
	{{- end }}
	{{- end }}
}

`))
)
