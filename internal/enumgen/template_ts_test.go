package enumgen

import (
	"bytes"
	"fmt"
	"testing"

	"github.com/effective-security/protoc-gen-go/api"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"google.golang.org/protobuf/compiler/protogen"
)

func TestApplyTSEnums(t *testing.T) {
	tests := []struct {
		name      string
		opts      TSOpts
		enums     []*EnumDescription
		wantError bool
	}{
		{
			name:      "empty enums list",
			opts:      TSOpts{BaseImportPath: "test"},
			enums:     []*EnumDescription{},
			wantError: false,
		},
		{
			name:      "nil enums list",
			opts:      TSOpts{BaseImportPath: "test"},
			enums:     nil,
			wantError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			buf := &bytes.Buffer{}

			err := ApplyTSEnums(buf, tt.opts, tt.enums)

			if tt.wantError {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestTsTempFuncs(t *testing.T) {
	// Test the template functions exist
	funcs := tsTempFuncs()

	expectedFuncs := []string{
		"enum_ts_name",
		"enum_ts_function_name",
		"enum_ts_import_name",
		"enum_ts_type",
		"enum_ts_parse_type",
	}

	for _, funcName := range expectedFuncs {
		t.Run(funcName+"_exists", func(t *testing.T) {
			_, exists := funcs[funcName]
			assert.True(t, exists, "Function %s should exist", funcName)
		})
	}
}

func TestTSImportsTemplate(t *testing.T) {
	tests := []struct {
		name         string
		data         tplTSImports
		wantContains []string
	}{
		{
			name: "empty file enum infos",
			data: tplTSImports{
				Opts:          TSOpts{BaseImportPath: "src/test"},
				FileEnumInfos: []FileEnumInfo{},
			},
			wantContains: []string{
				"// Code generated by protoc-gen-go-json. DO NOT EDIT.",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			buf := &bytes.Buffer{}
			err := tsImportsTemplate.Execute(buf, tt.data)
			require.NoError(t, err)

			output := buf.String()
			for _, want := range tt.wantContains {
				assert.Contains(t, output, want)
			}
		})
	}
}

func TestTSInterfaceTemplate(t *testing.T) {
	tests := []struct {
		name         string
		data         tplTSInterface
		wantContains []string
	}{
		{
			name: "interface template generation",
			data: tplTSInterface{},
			wantContains: []string{
				"interface ITypeNameInterface {",
				"[key: number | string]: string",
				"interface INameEnumInterface {",
				"[key: number | string]: number",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			buf := &bytes.Buffer{}
			err := tsInterfaceTemplate.Execute(buf, tt.data)
			require.NoError(t, err)

			output := buf.String()
			for _, want := range tt.wantContains {
				assert.Contains(t, output, want)
			}
		})
	}
}

func TestTSEnums(t *testing.T) {
	testcases := []struct {
		enums []*EnumDescription
		exp   string
	}{
		{
			enums: []*EnumDescription{
				{
					Name:     "TestEnum",
					FullName: "test.TestEnum",
					Enums: []*api.EnumMeta{
						{
							Value: -1,
							Name:  "Invalid",
						},
						{
							Value:   0,
							Name:    "Unknown",
							Display: "Unknown",
							Args:    []string{"Unknown"},
							Group:   "Unknown",
						},
						{
							Value:         1,
							Name:          "Active",
							Display:       "Active Status",
							Documentation: "Active description",
							Args:          []string{"Active", "Status"},
							Group:         "Status",
						},
					},
					ProtogenEnum: &protogen.Enum{
						Desc: api.File_annotations_proto.Enums().ByName("name"),
						GoIdent: protogen.GoIdent{
							GoName: "TestEnum",
						},
					},
				},
			},
			exp: `
//
// TestEnum
//

export const TestEnumName: ITypeNameInterface = {
    -1: 'Invalid',
    0: 'Unknown',
    1: 'Active',
}

export const TestEnumDisplayName: ITypeNameInterface = {
    -1: 'Invalid',
    0: 'Unknown',
    1: 'Active Status',
}

export const TestEnumGroup: ITypeNameInterface = {
    -1: '',
    0: 'Unknown',
    1: 'Status',
}

export const TestEnumNameEnum: INameEnumInterface = {
    'Invalid': -1,
    'Unknown': 0,
    'Active': 1,
}

export const TestEnumDisplayNameEnum: INameEnumInterface = {
    'Invalid': -1,
    'Unknown': 0,
    'Active Status': 1,
}

export const TestEnumGroupEnum: INameEnumInterface = {
    'Unknown': 0,
    'Status': 1,
}

export function getTestEnumName(
    opt: TestEnum | string,
): string {
    return TestEnumName[opt] || 'Unknown'
}

export function getTestEnumDisplayName(
    opt: TestEnum | string,
): string {
    return TestEnumDisplayName[opt] || 'Unknown'
}

export function getTestEnumGroup(
    opt: TestEnum | string,
): string {
    return TestEnumGroup[opt] || 'Unknown'
}

export function parseTestEnum(
    val: string | TestEnum,
): TestEnum {
    if (typeof val === 'number') {
        return val
    }
    // Try to parse as number first (for string representations like "0", "2", etc.)
    const numVal = parseInt(val, 10)
    if (!isNaN(numVal) && TestEnumName[numVal] !== undefined) {
        return numVal
    }
    return TestEnumNameEnum[val] || TestEnumDisplayNameEnum[val] || TestEnumGroupEnum[val] || 0
}

`,
		},
	}

	for i, tc := range testcases {
		t.Run(fmt.Sprintf("testcase_%d", i), func(t *testing.T) {
			buf := &bytes.Buffer{}
			err := ApplyTSEnums(buf, TSOpts{BaseImportPath: "test"}, tc.enums)
			assert.NoError(t, err)
			output := buf.String()
			assert.Equal(t, tc.exp, output)
		})
	}
}
