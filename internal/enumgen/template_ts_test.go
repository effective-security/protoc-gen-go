package enumgen

import (
	"bytes"
	"fmt"
	"testing"

	"github.com/effective-security/protoc-gen-go/api"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"google.golang.org/protobuf/compiler/protogen"
)

func TestApplyTSEnums(t *testing.T) {
	tests := []struct {
		name      string
		opts      TSOpts
		enums     []*EnumDescription
		wantError bool
	}{
		{
			name:      "empty enums list",
			opts:      TSOpts{BaseImportPath: "test"},
			enums:     []*EnumDescription{},
			wantError: false,
		},
		{
			name:      "nil enums list",
			opts:      TSOpts{BaseImportPath: "test"},
			enums:     nil,
			wantError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			buf := &bytes.Buffer{}

			err := ApplyTSEnums(buf, tt.opts, tt.enums)

			if tt.wantError {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestTsTempFuncs(t *testing.T) {
	// Test the template functions exist
	funcs := tsTempFuncs()

	expectedFuncs := []string{
		"enum_ts_name",
		"enum_ts_function_name",
		"enum_ts_import_name",
		"enum_ts_type",
		"enum_ts_parse_type",
	}

	for _, funcName := range expectedFuncs {
		t.Run(funcName+"_exists", func(t *testing.T) {
			_, exists := funcs[funcName]
			assert.True(t, exists, "Function %s should exist", funcName)
		})
	}
}

func TestTSImportsTemplate(t *testing.T) {
	tests := []struct {
		name         string
		data         tplTSImports
		wantContains []string
	}{
		{
			name: "empty file enum infos",
			data: tplTSImports{
				Opts:          TSOpts{BaseImportPath: "src/test"},
				FileEnumInfos: []FileEnumInfo{},
			},
			wantContains: []string{
				"// Code generated by protoc-gen-go-json. DO NOT EDIT.",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			buf := &bytes.Buffer{}
			err := tsImportsTemplate.Execute(buf, tt.data)
			require.NoError(t, err)

			output := buf.String()
			for _, want := range tt.wantContains {
				assert.Contains(t, output, want)
			}
		})
	}
}

func TestTSInterfaceTemplate(t *testing.T) {
	tests := []struct {
		name         string
		data         tplTSInterface
		wantContains []string
	}{
		{
			name: "interface template generation",
			data: tplTSInterface{},
			wantContains: []string{
				"interface ITypeNameInterface {",
				"[key: number | string]: string",
				"interface INameEnumInterface {",
				"[key: number | string]: number",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			buf := &bytes.Buffer{}
			err := tsInterfaceTemplate.Execute(buf, tt.data)
			require.NoError(t, err)

			output := buf.String()
			for _, want := range tt.wantContains {
				assert.Contains(t, output, want)
			}
		})
	}
}

func TestTSEnums(t *testing.T) {
	testcases := []struct {
		enums []*EnumDescription
		exp   string
	}{
		{
			enums: []*EnumDescription{
				{
					Name:     "TestEnum",
					FullName: "test.TestEnum",
					Enums: []*api.EnumMeta{
						{
							Value: 0,
							Name:  "Unknown",
						},
						{
							Value:   0,
							Name:    "Unknown",
							Display: "Unknown",
							Args:    []string{"Unknown"},
							Group:   "Unknown",
						},
						{
							Value:         1,
							Name:          "Active",
							Display:       "Active Status",
							Documentation: "Active description",
							Args:          []string{"Active", "Status"},
							Group:         "Status",
						},
					},
					ProtogenEnum: &protogen.Enum{
						Desc: api.File_annotations_proto.Enums().ByName("name"),
						GoIdent: protogen.GoIdent{
							GoName: "TestEnum",
						},
					},
				},
			},
			exp: "\n//\n// TestEnum\n//\n\nexport const TestEnumName: ITypeNameInterface = {\n    0: 'Unknown',\n    0: 'Unknown',\n    1: 'Active',\n}\n\nexport const TestEnumDisplayName: ITypeNameInterface = {\n    0: '',\n    0: 'Unknown',\n    1: 'Active Status',\n}\n\nexport const TestEnumGroup: ITypeNameInterface = {\n    0: '',\n    0: 'Unknown',\n    1: 'Status',\n}\n\nexport const TestEnumNameEnum: INameEnumInterface = {\n    'Unknown': 0,\n    'Unknown': 0,\n    'Active': 1,\n}\n\nexport const TestEnumDisplayNameEnum: INameEnumInterface = {\n    '': 0,\n    'Unknown': 0,\n    'Active Status': 1,\n}\n\nexport const TestEnumGroupEnum: INameEnumInterface = {\n    '': 0,\n    'Unknown': 0,\n    'Status': 1,\n}\n\nexport function getTestEnumName(\n    opt: TestEnum | string,\n): string {\n    return TestEnumName[opt] || 'Unknown'\n}\n\nexport function getTestEnumDisplayName(\n    opt: TestEnum | string,\n): string {\n    return TestEnumDisplayName[opt] || 'Unknown'\n}\n\nexport function getTestEnumGroup(\n    opt: TestEnum | string,\n): string {\n    return TestEnumGroup[opt] || 'Unknown'\n}\n\nexport function parseTestEnum(\n    val: string | TestEnum,\n): TestEnum {\n    if (typeof val === 'number') {\n        return val\n    }\n    // Try to parse as number first (for string representations like \"0\", \"2\", etc.)\n    const numVal = parseInt(val, 10)\n    if (!isNaN(numVal) && TestEnumName[numVal] !== undefined) {\n        return numVal\n    }\n    return TestEnumNameEnum[val] || TestEnumDisplayNameEnum[val] || TestEnumGroupEnum[val] || 0\n}\n\n",
		},
	}

	for i, tc := range testcases {
		t.Run(fmt.Sprintf("testcase_%d", i), func(t *testing.T) {
			buf := &bytes.Buffer{}
			err := ApplyTSEnums(buf, TSOpts{BaseImportPath: "test"}, tc.enums)
			assert.NoError(t, err)
			output := buf.String()
			assert.Equal(t, tc.exp, output)
		})
	}
}
