package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"path"
	"strings"
	"text/template"

	"github.com/Masterminds/sprig/v3"
	"github.com/cockroachdb/errors"
	"github.com/effective-security/protoc-gen-go/api"
	"github.com/effective-security/xlog"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

var logger = xlog.NewPackageLogger("github.com/effective-security/protoc-gen-go", "go-alloc")

var (
	log        = flag.Bool("logs", false, "output logs")
	out        = flag.String("out", "allocator", "output file prefix")
	importpath = flag.String("import", "", "go import path")
	pkg        = flag.String("package", "", "go package name")
)

func main() {
	flag.Parse()
	defer logger.Flush()

	protogen.Options{
		ParamFunc: flag.CommandLine.Set,
	}.Run(generator)
}

// generator
func generator(gp *protogen.Plugin) error {
	var formatter xlog.Formatter
	if *log {
		formatter = xlog.NewStringFormatter(os.Stderr).
			Options(xlog.FormatNoCaller, xlog.FormatSkipTime, xlog.FormatSkipLevel)
		xlog.SetGlobalLogLevel(xlog.INFO)
	} else {
		formatter = xlog.NewNilFormatter()
	}
	xlog.SetFormatter(formatter)

	fn := fmt.Sprintf("%s.pb.go", *out)
	logger.Infof("Generating %s\n", fn)

	gf := gp.NewGeneratedFile(fn, protogen.GoImportPath(*importpath))

	opts := Opts{
		Package: *pkg,
	}

	buf := &bytes.Buffer{}

	headerProduced := false
	for _, name := range gp.Request.FileToGenerate {
		f := gp.FilesByPath[name]
		for _, svc := range f.Services {
			if !headerProduced {
				if opts.Package == "" {
					opts.Package = string(f.GoPackageName)
				}

				if err := headerTemplate.Execute(buf, tplHeader{
					Opts: opts,
				}); err != nil {
					gp.Error(err)
					return errors.Wrapf(err, "failed to execute template: %s", *out)
				}
				headerProduced = true
			}

			cmdAliased := make(map[string]string, len(svc.Methods))

			for _, mthd := range svc.Methods {
				o := tplMethod{
					Opts: Opts{
						Package: string(f.GoPackageName),
					},
					Service: svc,
					Method:  mthd,
				}

				exts := mthd.Desc.Options()
				if exts != nil {
					pr := exts.ProtoReflect()
					o.CliCmd = proto.GetExtension(pr.Interface(), api.E_CliCmd).(string)

					if o.CliCmd != "" {
						if cmdAliased[o.CliCmd] != "" {
							err := errors.Errorf("cli command %q is already aliased to %q", o.CliCmd, cmdAliased[o.CliCmd])
							gp.Error(err)
							return err
						}
						cmdAliased[o.CliCmd] = mthd.GoName
					}

					ext := proto.GetExtension(pr.Interface(), api.E_AllowedRoles).(string)
					if ext != "" {
						o.Roles = strings.Split(ext, ",")
					}
					refresh := proto.GetExtension(pr.Interface(), api.E_RefreshInterval).(int32)
					if refresh != 0 {
						o.RefreshInterval = uint32(refresh)
					}
				}

				if err := allocatorTemplate.Execute(buf, o); err != nil {
					gp.Error(err)
					return errors.Wrapf(err, "failed to execute template: %s", *out)
				}
			}
		}
	}

	if headerProduced {
		if err := footerTemplate.Execute(buf, tplHeader{
			Opts: opts,
		}); err != nil {
			return errors.Wrapf(err, "failed to execute template: %s", *out)
		}
	}

	code, err := format.Source(buf.Bytes())
	if err != nil {
		return errors.Wrapf(err, "failed to format source")
	}
	_, err = gf.Write(code)

	return err
}

func tempFuncs() template.FuncMap {
	m := sprig.TxtFuncMap()
	m["type"] = func(pkg string, f *protogen.Message) string {
		ns := path.Base(string(f.GoIdent.GoImportPath))
		typ := f.GoIdent.GoName
		if ns != pkg {
			typ = ns + "." + typ
		}
		return typ
	}
	m["roles"] = func(roles []string) string {
		if len(roles) == 0 {
			return ""
		}

		val := "AllowedRoles: []string{"
		for i, r := range roles {
			val += "\"" + r + "\""
			if i+1 < len(r) {
				val += ","
			}
		}
		val += "},"
		return val
	}
	return m
}

// Opts are the options to set for rendering the template.
type Opts struct {
	// Package provides package name
	Package string
}

type tplHeader struct {
	Opts
}

type tplMethod struct {
	Opts

	Service         *protogen.Service
	Method          *protogen.Method
	Roles           []string
	CliCmd          string
	RefreshInterval uint32
}

var (
	headerTemplate = template.Must(template.New("header").
			Parse(`
// Code generated by protoc-gen-go-mock. DO NOT EDIT.

package {{.Package}}

import (
	"encoding/json"
	"net/http"

	"github.com/effective-security/porto/xhttp/httperror"
	"github.com/effective-security/porto/xhttp/marshal"
	"google.golang.org/protobuf/types/known/emptypb"
)

// RequestAllocator defines constructor to allocate Protobuf request
type RequestAllocator func() any

// CheckAccessFunc defines function to check access rights for the HTTP request
type CheckAccessFunc func(ctx context.Context, req any, action string) error

// MethodInfo provides info about RPC method
type MethodInfo struct {
	Allocator       RequestAllocator
	AllowedRoles    []string
	CliCmd          string
	RefreshInterval uint32
}

// UnmarshalRequest unmarshals JSON body of HTTP request to protobuf request
func UnmarshalRequest(w http.ResponseWriter, r *http.Request) (any, *MethodInfo, error) {
	info := methods[r.URL.Path]
	if info == nil {
		err := httperror.NotFound("path not found: %s", r.URL.Path)
		marshal.WriteJSON(w, r, err)
		return nil, nil, err
	}

	req := info.Allocator()
	err := marshal.DecodeBody(w, r, req)
	if err != nil {
		// DecodeBody writes error response and logs, if invalid request
		return nil, nil, err
	}
	return req, info, nil
}

// GetMethodInfo returns MethodInfo
func GetMethodInfo(method string) *MethodInfo {
	return methods[method]
}

// GetMethodsInfo returns map of methods
func GetMethodsInfo() map[string]*MethodInfo {
	return methods
}

// GetMethodAliases returns map of method CLI commands to method names
func GetMethodAliases() map[string]string {
	res := make(map[string]string, len(methods))
	for fn, method := range methods {
		if method.CliCmd != "" {
			res[method.CliCmd] = fn
		}
	}
	return res
}

// methods defines map for routes
var methods = map[string]*MethodInfo{
`))

	footerTemplate = template.Must(template.New("footer").
			Parse(`
}
`))

	allocatorTemplate = template.Must(template.New("allocator").
				Funcs(tempFuncs()).
				Parse(`
	{{.Service.GoName}}_{{.Method.GoName}}_FullMethodName: {
		Allocator: func() any { return new({{type .Package .Method.Input}}) },
		{{- if .CliCmd }}
		CliCmd: "{{.CliCmd}}",
		{{- end }}
		{{- if .RefreshInterval }}
		RefreshInterval: {{.RefreshInterval}},
		{{- end }}
		{{roles .Roles}}
	},
`))
)
