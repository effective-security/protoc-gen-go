package main

import (
	"flag"
	"fmt"
	"os"
	"path"
	"strings"
	"text/template"

	"github.com/Masterminds/sprig/v3"
	"github.com/effective-security/protoc-gen-go/api"
	"github.com/effective-security/xlog"
	"github.com/pkg/errors"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

var logger = xlog.NewPackageLogger("github.com/effective-security/protoc-gen-go", "go-alloc")

var (
	log        = flag.Bool("logs", false, "output logs")
	out        = flag.String("out", "allocator", "output file prefix")
	importpath = flag.String("import", "", "go import path")
	pkg        = flag.String("package", "", "go package name")
)

func main() {
	flag.Parse()
	defer logger.Flush()

	protogen.Options{
		ParamFunc: flag.CommandLine.Set,
	}.Run(generator)
}

// generator
func generator(gp *protogen.Plugin) error {
	var formatter xlog.Formatter
	if *log {
		formatter = xlog.NewStringFormatter(os.Stderr).
			Options(xlog.FormatNoCaller, xlog.FormatSkipTime, xlog.FormatSkipLevel)
		xlog.SetGlobalLogLevel(xlog.INFO)
	} else {
		formatter = xlog.NewNilFormatter()
	}
	xlog.SetFormatter(formatter)

	fn := fmt.Sprintf("%s.pb.go", *out)
	logger.Infof("Generating %s\n", fn)

	gf := gp.NewGeneratedFile(fn, protogen.GoImportPath(*importpath))

	opts := Opts{
		Package: *pkg,
	}

	headerProduced := false
	for _, name := range gp.Request.FileToGenerate {
		f := gp.FilesByPath[name]
		for _, svc := range f.Services {
			if !headerProduced {
				if opts.Package == "" {
					opts.Package = string(f.GoPackageName)
				}

				if err := headerTemplate.Execute(gf, tplHeader{
					Opts: opts,
				}); err != nil {
					gp.Error(err)
					return errors.Wrapf(err, "failed to execute template: %s", *out)
				}
				headerProduced = true
			}

			for _, mthd := range svc.Methods {
				o := tplMethod{
					Opts: Opts{
						Package: string(f.GoPackageName),
					},
					Service: svc,
					Method:  mthd,
				}

				exts := mthd.Desc.Options()
				if exts != nil {
					pr := exts.ProtoReflect()
					ext := proto.GetExtension(pr.Interface(), api.E_AllowedRoles).(string)
					if ext != "" {
						o.Roles = strings.Split(ext, ",")
					}
				}

				if err := methodTemplate.Execute(gf, o); err != nil {
					gp.Error(err)
					return errors.Wrapf(err, "failed to execute template: %s", *out)
				}
			}
		}
	}

	if headerProduced {
		if err := footerTemplate.Execute(gf, tplHeader{
			Opts: opts,
		}); err != nil {
			return errors.Wrapf(err, "failed to execute template: %s", *out)
		}
	}

	return nil
}

func tempFuncs() template.FuncMap {
	m := sprig.TxtFuncMap()
	m["type"] = func(pkg string, f *protogen.Message) string {
		ns := path.Base(string(f.GoIdent.GoImportPath))
		typ := f.GoIdent.GoName
		if ns != pkg {
			typ = ns + "." + typ
		}
		return typ
	}
	m["roles"] = func(roles []string) string {
		if len(roles) == 0 {
			return ""
		}

		val := "AllowedRoles: []string{"
		for i, r := range roles {
			val += "\"" + r + "\""
			if i+1 < len(r) {
				val += ","
			}
		}
		val += "},"
		return val
	}
	return m
}

// Opts are the options to set for rendering the template.
type Opts struct {
	// Package provides package name
	Package string
}

type tplHeader struct {
	Opts
}

type tplMethod struct {
	Opts

	Service *protogen.Service
	Method  *protogen.Method
	Roles   []string
}

var (
	headerTemplate = template.Must(template.New("header").
			Parse(`
// Code generated by protoc-gen-go-mock. DO NOT EDIT.

package {{.Package}}

import (
	"encoding/json"
	"net/http"

	"github.com/effective-security/porto/xhttp/httperror"
	"github.com/effective-security/porto/xhttp/marshal"
	"google.golang.org/protobuf/types/known/emptypb"
)

// RequestAllocator defines constructor to allocate Protobuf request
type RequestAllocator func() any

// MethodInfo provides info about RPC method
type MethodInfo struct {
	Allocator    RequestAllocator
	AllowedRoles []string
}

// UnmarshalRequest unmarshals JSON body of HTTP request to protobuf request
func UnmarshalRequest(w http.ResponseWriter, r *http.Request) (any, *MethodInfo, error) {
	info := methods[r.URL.Path]
	if info == nil {
		err := httperror.NotFound("path not found: %s", r.URL.Path)
		marshal.WriteJSON(w, r, err)
		return nil, nil, err
	}

	req := info.Allocator()
	err := marshal.DecodeBody(w, r, req)
	if err != nil {
		// DecodeBody writes error response and logs, if invalid request
		return nil, nil, err
	}
	return req, info, nil
}

// GetMethodInfo returns MethodInfo
func GetMethodInfo(method string) *MethodInfo {
	return methods[method]
}

// methods defines map for routes
var methods = map[string]*MethodInfo{
`))

	footerTemplate = template.Must(template.New("footer").
			Parse(`
}
`))

	methodTemplate = template.Must(template.New("method").
			Funcs(tempFuncs()).
			Parse(`
	"/{{.Package}}.{{.Service.GoName}}/{{.Method.GoName}}": {
		Allocator: func() any { return new({{type .Package .Method.Input}}) },
		{{roles .Roles}}
	},
`))
)
